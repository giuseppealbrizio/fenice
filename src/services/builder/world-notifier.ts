import type { WorldWsManager } from '../../ws/world-manager.js';
import type { WorldDeltaEvent } from '../../schemas/world-delta.schema.js';
import type { BuilderJobStatus, BuilderGeneratedFile } from '../../schemas/builder.schema.js';
import { createLogger } from '../../utils/logger.js';

const logger = createLogger('fenice', process.env['LOG_LEVEL'] ?? 'info');

const STATUS_MESSAGES: Record<BuilderJobStatus, string> = {
  queued: 'Job queued',
  reading_context: 'Reading project context',
  planning: 'Generating execution plan',
  plan_ready: 'Plan ready for approval',
  generating: 'Generating code via Claude API',
  writing_files: 'Writing generated files to disk',
  validating: 'Running validation (lint + typecheck + test)',
  creating_pr: 'Creating pull request on GitHub',
  committing: 'Committing changes directly to main',
  completed: 'Pipeline completed successfully',
  completed_draft: 'Pipeline completed as draft (validation issues)',
  rolled_back: 'Direct commit rolled back due to failure',
  failed: 'Pipeline failed',
  rejected: 'Plan rejected by user',
};

/**
 * Emits builder progress events and synthetic deltas via the world WebSocket.
 */
export class BuilderWorldNotifier {
  constructor(private readonly wsManager: WorldWsManager) {}

  /**
   * Broadcast a builder.progress delta event to all subscribed clients.
   */
  emitProgress(jobId: string, status: BuilderJobStatus): void {
    const events: WorldDeltaEvent[] = [
      {
        type: 'builder.progress',
        entityId: jobId,
        payload: {
          jobId,
          status,
          message: STATUS_MESSAGES[status],
        },
      },
    ];

    this.wsManager.broadcastDelta(events);
    logger.info({ jobId, status }, 'Builder progress event emitted');
  }

  /**
   * Broadcast a granular tool-activity event during code generation.
   */
  emitToolActivity(jobId: string, tool: string, path: string): void {
    const label =
      tool === 'write_file' ? 'Creating' : tool === 'modify_file' ? 'Modifying' : 'Reading';
    const detail = `${label} ${path}`;

    const events: WorldDeltaEvent[] = [
      {
        type: 'builder.progress',
        entityId: jobId,
        payload: {
          jobId,
          status: 'generating',
          message: 'Generating code via Claude API',
          detail,
        },
      },
    ];

    this.wsManager.broadcastDelta(events);
  }

  /**
   * Emit synthetic service.upserted and endpoint.upserted deltas so the 3D
   * world renders new buildings immediately â€” before the PR is merged and
   * the OpenAPI spec refreshes.
   */
  emitSyntheticDeltas(jobId: string, files: BuilderGeneratedFile[]): void {
    const events: WorldDeltaEvent[] = [];

    // Detect services and endpoints from generated file paths
    const serviceIds = new Set<string>();
    const routeFiles = files.filter((f) => f.path.includes('/routes/'));
    const schemaFiles = files.filter((f) => f.path.includes('/schemas/'));

    for (const routeFile of routeFiles) {
      const tag = extractTagFromPath(routeFile.path);
      if (!tag) continue;

      const serviceId = `service:${tag}`;
      if (!serviceIds.has(serviceId)) {
        serviceIds.add(serviceId);

        events.push({
          type: 'service.upserted',
          entityId: serviceId,
          payload: {
            id: serviceId,
            tag,
            endpointCount: 0, // Will be updated below
          },
        });
      }
    }

    // Count endpoints per service from schema files (each schema ~ an endpoint group)
    for (const schemaFile of schemaFiles) {
      const tag = extractTagFromPath(schemaFile.path);
      if (!tag) continue;

      const serviceId = `service:${tag}`;
      const endpointId = `endpoint:${tag}:${jobId.slice(0, 8)}`;

      events.push({
        type: 'endpoint.upserted',
        entityId: endpointId,
        payload: {
          id: endpointId,
          serviceId,
          path: `/api/v1/${tag}`,
          method: 'get',
          summary: `Generated by builder job ${jobId.slice(0, 8)}`,
          hasAuth: true,
          parameterCount: 0,
        },
      });

      // Update endpoint count on the matching service event
      const serviceEvent = events.find(
        (e) => e.type === 'service.upserted' && e.entityId === serviceId
      );
      if (serviceEvent?.type === 'service.upserted') {
        serviceEvent.payload.endpointCount += 1;
      }
    }

    if (events.length > 0) {
      this.wsManager.broadcastDelta(events);
      logger.info({ jobId, eventCount: events.length }, 'Synthetic world deltas emitted');
    }
  }
}

/**
 * Extract a service tag from a file path like `src/routes/product.routes.ts`
 * or `src/schemas/product.schema.ts`.
 */
function extractTagFromPath(filePath: string): string | null {
  const segments = filePath.split('/');
  const fileName = segments[segments.length - 1];
  if (!fileName) return null;

  // Match patterns like "product.routes.ts", "product.schema.ts", "product.model.ts"
  const match = /^([a-z][a-z0-9-]*)\.(?:routes|schema|model|service)\.ts$/.exec(fileName);
  return match?.[1] ?? null;
}

export { extractTagFromPath };
