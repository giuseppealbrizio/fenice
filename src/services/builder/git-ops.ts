import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { simpleGit, type SimpleGit } from 'simple-git';
import { createLogger } from '../../utils/logger.js';

const execFileAsync = promisify(execFile);
const logger = createLogger('fenice', process.env['LOG_LEVEL'] ?? 'info');

// ---------------------------------------------------------------------------
// GitHub remote auto-detection
// ---------------------------------------------------------------------------

export function parseGitHubUrl(url: string): { owner: string; repo: string } | null {
  // HTTPS: https://github.com/owner/repo.git
  const httpsMatch = /github\.com\/([^/]+)\/([^/.]+)/.exec(url);
  if (httpsMatch?.[1] && httpsMatch[2]) {
    return { owner: httpsMatch[1], repo: httpsMatch[2] };
  }
  // SSH: git@github.com:owner/repo.git
  const sshMatch = /github\.com:([^/]+)\/([^/.]+)/.exec(url);
  if (sshMatch?.[1] && sshMatch[2]) {
    return { owner: sshMatch[1], repo: sshMatch[2] };
  }
  return null;
}

export async function detectGitHubRemote(
  projectRoot: string
): Promise<{ owner: string; repo: string } | null> {
  try {
    const git: SimpleGit = simpleGit(projectRoot);
    const url = await git.remote(['get-url', 'origin']);
    if (!url) return null;
    return parseGitHubUrl(url.trim());
  } catch {
    return null;
  }
}

export async function detectGitHubToken(): Promise<string | null> {
  // 1. Env var takes priority
  const envToken = process.env['GITHUB_TOKEN'];
  if (envToken) return envToken;

  // 2. Try GitHub CLI
  try {
    const { stdout } = await execFileAsync('gh', ['auth', 'token'], { timeout: 5000 });
    const token = stdout.trim();
    if (token) {
      logger.info('GitHub token detected via gh CLI');
      return token;
    }
  } catch {
    // gh not installed or not authenticated — fall through
  }

  return null;
}

export interface GitCommitResult {
  branch: string;
  commitHash: string;
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 40);
}

export async function createBranchAndCommit(
  projectRoot: string,
  jobId: string,
  prompt: string,
  filePaths: string[]
): Promise<GitCommitResult> {
  const git: SimpleGit = simpleGit(projectRoot);

  const slug = slugify(prompt);
  const branch = `builder/${jobId}-${slug}`;

  // Create and checkout new branch from current HEAD
  await git.checkoutLocalBranch(branch);
  logger.info({ branch }, 'Created builder branch');

  // Stage all generated/modified files
  await git.add(filePaths);

  // Build conventional commit message
  const shortPrompt = prompt.length > 60 ? prompt.slice(0, 60) + '...' : prompt;
  const commitMessage = [
    `feat(builder): ${shortPrompt}`,
    '',
    `Generated by AI Builder (job: ${jobId})`,
    '',
    'Files:',
    ...filePaths.map((f) => `  - ${f}`),
    '',
    'Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>',
  ].join('\n');

  const commitResult = await git.commit(commitMessage);
  const commitHash = commitResult.commit || 'unknown';
  logger.info({ branch, commitHash }, 'Committed generated files');

  return { branch, commitHash };
}

export async function createDraftBranchAndCommit(
  projectRoot: string,
  jobId: string,
  prompt: string,
  filePaths: string[]
): Promise<GitCommitResult> {
  const git: SimpleGit = simpleGit(projectRoot);

  const slug = slugify(prompt);
  const branch = `draft/${jobId}-${slug}`;

  await git.checkoutLocalBranch(branch);
  logger.info({ branch }, 'Created draft branch');

  await git.add(filePaths);

  const shortPrompt = prompt.length > 60 ? prompt.slice(0, 60) + '...' : prompt;
  const commitMessage = [
    `draft(builder): ${shortPrompt}`,
    '',
    `Generated by AI Builder (job: ${jobId})`,
    'NOTE: Validation failed — this PR needs manual fixes.',
    '',
    'Files:',
    ...filePaths.map((f) => `  - ${f}`),
    '',
    'Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>',
  ].join('\n');

  const commitResult = await git.commit(commitMessage);
  return { branch, commitHash: commitResult.commit || 'unknown' };
}

export async function pushBranch(projectRoot: string, branch: string): Promise<void> {
  const git: SimpleGit = simpleGit(projectRoot);
  await git.push('origin', branch, ['--set-upstream']);
  logger.info({ branch }, 'Pushed branch to remote');
}

export async function cleanupBranch(projectRoot: string, branch: string): Promise<void> {
  const git: SimpleGit = simpleGit(projectRoot);

  // Switch back to main before deleting
  const currentBranch = (await git.branch()).current;
  if (currentBranch === branch) {
    await git.checkout('main');
  }

  try {
    await git.deleteLocalBranch(branch, true);
    logger.info({ branch }, 'Cleaned up builder branch');
  } catch {
    logger.warn({ branch }, 'Failed to clean up branch');
  }
}
