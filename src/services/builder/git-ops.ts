import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { mkdtemp, rm, symlink } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { simpleGit, type SimpleGit } from 'simple-git';
import { createLogger } from '../../utils/logger.js';

const execFileAsync = promisify(execFile);
const logger = createLogger('fenice', process.env['LOG_LEVEL'] ?? 'info');

// ---------------------------------------------------------------------------
// GitHub remote auto-detection
// ---------------------------------------------------------------------------

export function parseGitHubUrl(url: string): { owner: string; repo: string } | null {
  // HTTPS: https://github.com/owner/repo.git
  const httpsMatch = /github\.com\/([^/]+)\/([^/.]+)/.exec(url);
  if (httpsMatch?.[1] && httpsMatch[2]) {
    return { owner: httpsMatch[1], repo: httpsMatch[2] };
  }
  // SSH: git@github.com:owner/repo.git
  const sshMatch = /github\.com:([^/]+)\/([^/.]+)/.exec(url);
  if (sshMatch?.[1] && sshMatch[2]) {
    return { owner: sshMatch[1], repo: sshMatch[2] };
  }
  return null;
}

export async function detectGitHubRemote(
  projectRoot: string
): Promise<{ owner: string; repo: string } | null> {
  try {
    const git: SimpleGit = simpleGit(projectRoot);
    const url = await git.remote(['get-url', 'origin']);
    if (!url) return null;
    return parseGitHubUrl(url.trim());
  } catch {
    return null;
  }
}

export async function detectGitHubToken(): Promise<string | null> {
  // 1. Env var takes priority
  const envToken = process.env['GITHUB_TOKEN'];
  if (envToken) return envToken;

  // 2. Try GitHub CLI
  try {
    const { stdout } = await execFileAsync('gh', ['auth', 'token'], { timeout: 5000 });
    const token = stdout.trim();
    if (token) {
      logger.info('GitHub token detected via gh CLI');
      return token;
    }
  } catch {
    // gh not installed or not authenticated — fall through
  }

  return null;
}

export interface GitCommitResult {
  branch: string;
  commitHash: string;
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 40);
}

export async function createBranchAndCommit(
  projectRoot: string,
  jobId: string,
  prompt: string,
  filePaths: string[]
): Promise<GitCommitResult> {
  const git: SimpleGit = simpleGit(projectRoot);

  const slug = slugify(prompt);
  const branch = `builder/${jobId}-${slug}`;

  // Create and checkout new branch from current HEAD
  await git.checkoutLocalBranch(branch);
  logger.info({ branch }, 'Created builder branch');

  // Stage all generated/modified files
  await git.add(filePaths);

  // Build conventional commit message
  const shortPrompt = prompt.length > 60 ? prompt.slice(0, 60) + '...' : prompt;
  const commitMessage = [
    `feat(builder): ${shortPrompt}`,
    '',
    `Generated by AI Builder (job: ${jobId})`,
    '',
    'Files:',
    ...filePaths.map((f) => `  - ${f}`),
    '',
    'Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>',
  ].join('\n');

  const commitResult = await git.commit(commitMessage, undefined, { '--no-verify': null });
  const commitHash = commitResult.commit || 'unknown';
  logger.info({ branch, commitHash }, 'Committed generated files');

  return { branch, commitHash };
}

export async function createDraftBranchAndCommit(
  projectRoot: string,
  jobId: string,
  prompt: string,
  filePaths: string[]
): Promise<GitCommitResult> {
  const git: SimpleGit = simpleGit(projectRoot);

  const slug = slugify(prompt);
  const branch = `draft/${jobId}-${slug}`;

  await git.checkoutLocalBranch(branch);
  logger.info({ branch }, 'Created draft branch');

  await git.add(filePaths);

  const shortPrompt = prompt.length > 60 ? prompt.slice(0, 60) + '...' : prompt;
  const commitMessage = [
    `draft(builder): ${shortPrompt}`,
    '',
    `Generated by AI Builder (job: ${jobId})`,
    'NOTE: Validation failed — this PR needs manual fixes.',
    '',
    'Files:',
    ...filePaths.map((f) => `  - ${f}`),
    '',
    'Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>',
  ].join('\n');

  const commitResult = await git.commit(commitMessage, undefined, { '--no-verify': null });
  return { branch, commitHash: commitResult.commit || 'unknown' };
}

export async function amendCommitWithFiles(
  projectRoot: string,
  filePaths: string[]
): Promise<void> {
  const git: SimpleGit = simpleGit(projectRoot);
  await git.add(filePaths);
  await git.commit('fix: apply repair', undefined, {
    '--amend': null,
    '--no-verify': null,
    '--no-edit': null,
  });
  logger.info({ fileCount: filePaths.length }, 'Amended commit with repaired files');
}

export async function pushBranch(projectRoot: string, branch: string): Promise<void> {
  const git: SimpleGit = simpleGit(projectRoot);
  await git.push('origin', branch, ['--set-upstream']);
  logger.info({ branch }, 'Pushed branch to remote');
}

export async function cleanupBranch(projectRoot: string, branch: string): Promise<void> {
  const git: SimpleGit = simpleGit(projectRoot);

  // Switch back to main before deleting.
  // Use --force to discard uncommitted changes (e.g. from repair writes).
  // Safe because callers re-write files after cleanup if needed (draft PR path).
  const currentBranch = (await git.branch()).current;
  if (currentBranch === branch) {
    await git.checkout(['--force', 'main']);
  }

  try {
    await git.deleteLocalBranch(branch, true);
    logger.info({ branch }, 'Cleaned up builder branch');
  } catch {
    logger.warn({ branch }, 'Failed to clean up branch');
  }
}

// ---------------------------------------------------------------------------
// Git worktree operations — isolate builder from tsx watch
// ---------------------------------------------------------------------------

export interface WorktreeResult {
  /** Absolute path to the worktree directory */
  worktreePath: string;
  /** Branch name created in the worktree */
  branch: string;
}

/**
 * Creates a git worktree on a new branch, isolated from the main checkout.
 * This prevents tsx watch from restarting when builder writes/commits files.
 */
export async function createWorktree(
  projectRoot: string,
  jobId: string,
  prompt: string
): Promise<WorktreeResult> {
  const git: SimpleGit = simpleGit(projectRoot);
  const slug = slugify(prompt);
  const branch = `builder/${jobId}-${slug}`;
  const worktreeDir = await mkdtemp(join(tmpdir(), 'fenice-builder-'));

  await git.raw(['worktree', 'add', '-b', branch, worktreeDir, 'HEAD']);
  // Symlink node_modules so tsc/eslint/vitest can resolve dependencies
  await symlink(join(projectRoot, 'node_modules'), join(worktreeDir, 'node_modules'), 'junction');
  logger.info({ branch, worktreePath: worktreeDir }, 'Created builder worktree');

  return { worktreePath: worktreeDir, branch };
}

/**
 * Creates a draft worktree (for failed validation, draft PR path).
 */
export async function createDraftWorktree(
  projectRoot: string,
  jobId: string,
  prompt: string
): Promise<WorktreeResult> {
  const git: SimpleGit = simpleGit(projectRoot);
  const slug = slugify(prompt);
  const branch = `draft/${jobId}-${slug}`;
  const worktreeDir = await mkdtemp(join(tmpdir(), 'fenice-builder-draft-'));

  await git.raw(['worktree', 'add', '-b', branch, worktreeDir, 'HEAD']);
  await symlink(join(projectRoot, 'node_modules'), join(worktreeDir, 'node_modules'), 'junction');
  logger.info({ branch, worktreePath: worktreeDir }, 'Created draft worktree');

  return { worktreePath: worktreeDir, branch };
}

/**
 * Commits files already written in the worktree.
 */
export async function commitInWorktree(
  worktreePath: string,
  jobId: string,
  prompt: string,
  filePaths: string[],
  isDraft = false
): Promise<string> {
  const git: SimpleGit = simpleGit(worktreePath);
  await git.add(filePaths);

  const prefix = isDraft ? 'draft(builder)' : 'feat(builder)';
  const shortPrompt = prompt.length > 60 ? prompt.slice(0, 60) + '...' : prompt;
  const commitMessage = [
    `${prefix}: ${shortPrompt}`,
    '',
    `Generated by AI Builder (job: ${jobId})`,
    ...(isDraft ? ['NOTE: Validation failed — this PR needs manual fixes.'] : []),
    '',
    'Files:',
    ...filePaths.map((f) => `  - ${f}`),
    '',
    'Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>',
  ].join('\n');

  const result = await git.commit(commitMessage, undefined, { '--no-verify': null });
  logger.info({ commitHash: result.commit, fileCount: filePaths.length }, 'Committed in worktree');
  return result.commit || 'unknown';
}

/**
 * Pushes a branch from a worktree.
 */
export async function pushFromWorktree(worktreePath: string, branch: string): Promise<void> {
  const git: SimpleGit = simpleGit(worktreePath);
  await git.push('origin', branch, ['--set-upstream']);
  logger.info({ branch }, 'Pushed branch from worktree');
}

/**
 * Removes a worktree and deletes its local branch.
 * Safe to call even if the worktree was already removed.
 */
export async function removeWorktree(
  projectRoot: string,
  worktreePath: string,
  branch: string
): Promise<void> {
  const git: SimpleGit = simpleGit(projectRoot);

  try {
    await git.raw(['worktree', 'remove', worktreePath, '--force']);
  } catch {
    // Worktree may already be gone — try rm as fallback
    try {
      await rm(worktreePath, { recursive: true, force: true });
      await git.raw(['worktree', 'prune']);
    } catch {
      logger.warn({ worktreePath }, 'Failed to clean up worktree directory');
    }
  }

  try {
    await git.deleteLocalBranch(branch, true);
    logger.info({ branch, worktreePath }, 'Cleaned up worktree and branch');
  } catch {
    logger.warn({ branch }, 'Failed to delete worktree branch');
  }
}
