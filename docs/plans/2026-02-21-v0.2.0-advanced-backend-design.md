# v0.2.0 — Advanced Backend Features Design

**Date:** 2026-02-21
**Status:** Approved
**Author:** Giuseppe Albrizio + Claude

## Overview

v0.2.0 expands FENICE with 10 production features organized in 3 implementation waves. The architecture follows a Middleware-First strategy: cross-cutting middleware first, then API enhancements, then feature modules.

## Scope

All 10 features from the ROADMAP:

| Wave | Feature | Priority |
|------|---------|----------|
| 1 | Request Validation Middleware | Foundation |
| 1 | RBAC Middleware | Foundation |
| 1 | Rate Limiting Middleware | Foundation |
| 2 | Pagination (cursor-based) | API Enhancement |
| 2 | Search & Filtering | API Enhancement |
| 2 | API Versioning Strategy | API Enhancement |
| 3 | Email Verification | Feature Module |
| 3 | Password Reset | Feature Module |
| 3 | File Upload (chunked, 100MB) | Feature Module |
| 3 | WebSocket (notifications + chat + collaboration) | Feature Module |

## Architecture Decisions

### AD-1: Middleware-First Strategy

Cross-cutting middleware (RBAC, rate limiting, validation) are implemented first because all feature modules depend on them. This ensures consistent security and validation across all new endpoints.

### AD-2: In-Memory Rate Limiting with Abstract Store

Rate limiting uses an in-memory sliding window counter with an abstract `RateLimitStore` interface. This avoids adding Redis as a dependency in v0.2.0 while making the Redis upgrade in v0.3.0 a simple store swap.

### AD-3: Cursor-Based Pagination

Cursor-based pagination instead of offset-based. More performant for large datasets (no `skip(N)` in MongoDB), consistent results when data changes between pages, and naturally compatible with real-time feeds.

### AD-4: Chunked Upload for Large Files

Files up to 100MB use a 3-phase chunked upload (init → chunks → complete) instead of single-request upload. This enables progress tracking, resumable uploads, and avoids memory pressure from buffering entire files.

### AD-5: WebSocket with Room Pattern

WebSocket uses a room-based architecture (Connection Manager pattern) rather than pub/sub. Rooms provide natural grouping for chat channels, notification topics, and collaboration sessions.

---

## Wave 1: Cross-Cutting Middleware

### 1.1 Request Validation Middleware

Generic Zod validation middleware for non-OpenAPI routes (WebSocket params, upload metadata, custom endpoints).

```typescript
// src/middleware/validate.ts
function validate<B, Q, P>(schemas: {
  body?: ZodSchema<B>;
  query?: ZodSchema<Q>;
  params?: ZodSchema<P>;
}): MiddlewareHandler
```

**Note:** `@hono/zod-openapi` already handles validation for OpenAPI routes. This middleware complements it for cases where OpenAPI route definitions aren't used.

**Error format:** Reuses existing `ValidationError` → `{ error: { code: 'VALIDATION_ERROR', details: [{ field, message }] } }`

### 1.2 RBAC Middleware

Role-based access control with numeric hierarchy.

**Roles (existing in User model):**

| Role | Hierarchy | Capabilities |
|------|-----------|-------------|
| `superAdmin` | 60 | Full system access, user management, config |
| `admin` | 50 | User CRUD, moderation, analytics |
| `employee` | 40 | Internal operations, extended access |
| `client` | 30 | Client-facing features, own data management |
| `vendor` | 20 | Vendor-specific operations, limited scope |
| `user` | 10 | Profile management, read-only public resources |

**Middleware factory:**

```typescript
// src/middleware/rbac.ts
const ROLE_HIERARCHY: Record<Role, number> = {
  superAdmin: 60, admin: 50, employee: 40,
  client: 30, vendor: 20, user: 10,
};

// Minimum role level
function requireRole(minRole: Role): MiddlewareHandler

// Explicit role list (OR logic)
function requireRoles(roles: Role[]): MiddlewareHandler
```

**Usage in routes:**

```typescript
router.openapi(deleteUserRoute, requireRole('admin'), handler);
router.openapi(listUsersRoute, requireRole('employee'), handler);
```

### 1.3 Rate Limiting Middleware

Sliding window counter with configurable limits per route group.

**Default limits:**

| Route Group | Window | Max Requests |
|-------------|--------|-------------|
| Default (`/api/v1/*`) | 60s | 100 |
| Auth (`/api/v1/auth/*`) | 60s | 10 |
| Upload (`/api/v1/upload/*`) | 60s | 5 |
| WebSocket | 60s | 20 connections |

**Key strategy:** IP address for unauthenticated requests, userId for authenticated.

**Response headers:**
- `X-RateLimit-Limit` — max requests in window
- `X-RateLimit-Remaining` — remaining requests
- `X-RateLimit-Reset` — Unix timestamp when window resets

**429 response:** `{ error: { code: 'RATE_LIMIT_EXCEEDED', message, retryAfter } }`

**Abstract store interface (future-proof for Redis in v0.3.0):**

```typescript
interface RateLimitStore {
  increment(key: string): Promise<{ count: number; resetAt: number }>;
  reset(key: string): Promise<void>;
}

class MemoryRateLimitStore implements RateLimitStore { ... }
// v0.3.0: class RedisRateLimitStore implements RateLimitStore { ... }
```

**Cleanup:** Periodic timer (every 60s) removes expired entries from the Map.

---

## Wave 2: API Enhancement

### 2.1 Cursor-Based Pagination

Extends the existing `PaginationSchema` in `common.schema.ts`.

**Query parameters:**

```
GET /api/v1/users?cursor=<base64>&limit=20&sort=createdAt&order=desc
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `cursor` | string | null | Base64-encoded cursor (opaque to client) |
| `limit` | number | 20 | Items per page (max 100) |
| `sort` | string | `createdAt` | Sort field |
| `order` | `asc` \| `desc` | `desc` | Sort direction |

**Response envelope:**

```typescript
{
  data: T[],
  pagination: {
    hasNext: boolean,
    nextCursor: string | null,
    total?: number              // optional, disabled for performance on large collections
  }
}
```

**Cursor implementation:** Base64-encoded JSON with `{ id, sortValue }` for deterministic pagination. Uses MongoDB `$gt`/`$lt` with compound sort on `(sortField, _id)`.

**Generic utility:** `paginateQuery(model, filter, options)` — reusable for any Mongoose model.

### 2.2 Search & Filtering

Query builder pattern that converts validated query params to MongoDB filters.

**User endpoint filters:**

```
GET /api/v1/users?search=giuseppe&role=admin&active=true&createdAfter=2026-01-01
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `search` | string | Text search on email, username, fullName (case-insensitive regex) |
| `role` | RoleEnum | Exact role filter |
| `active` | boolean | Active status filter |
| `createdAfter` | ISO date | Created after date |
| `createdBefore` | ISO date | Created before date |

**Implementation:**

```typescript
// src/utils/query-builder.ts
function buildMongoFilter(params: ValidatedQueryParams): FilterQuery<T>
```

Generic `buildMongoFilter()` is reusable for future models. Zod schemas validate all query params before they reach the builder.

### 2.3 API Versioning Strategy

Path-based versioning (already in use with `/api/v1`). v0.2.0 adds infrastructure for managing multiple versions.

**Version middleware:**

```typescript
app.use('/api/*', (c, next) => {
  const version = c.req.path.match(/\/api\/(v\d+)\//)?.[1] ?? 'v1';
  c.set('apiVersion', version);
  return next();
});
```

**Mount pattern:**

```typescript
// src/index.ts
app.route('/api/v1', v1Router);  // all v1 routes
// Future: app.route('/api/v2', v2Router);
```

**Scope for v0.2.0:** Infrastructure only (middleware + mount pattern). No v2 routes — those come when breaking changes require a new version.

---

## Wave 3: Feature Modules

### 3.1 Email Verification

**Flow:**

```
POST /auth/signup
  → Create user (emailVerified: false)
  → Generate token (crypto.randomBytes(32), hashed with SHA-256 in DB)
  → Set emailVerificationExpires (24h)
  → EmailAdapter.send() → link: {CLIENT_URL}/verify-email?token=xxx

GET /auth/verify-email?token=xxx
  → Hash incoming token with SHA-256
  → Find user with matching hash + non-expired
  → Set emailVerified: true
  → Clear token fields

POST /auth/resend-verification
  → Requires auth (userId from JWT)
  → Rate limited (10/min)
  → Regenerate token + re-send email
```

**New User model fields:**

```typescript
emailVerified: { type: Boolean, default: false }
emailVerificationToken: { type: String, select: false }
emailVerificationExpires: { type: Date }
```

**Behavior change:** After v0.2.0, users must verify email before login returns tokens. Unverified users get `403 EMAIL_NOT_VERIFIED`.

### 3.2 Password Reset

**Flow:**

```
POST /auth/request-password-reset → body: { email }
  → Find user by email (if not found, still respond 200 — don't leak existence)
  → Generate token (crypto.randomBytes(32), SHA-256 hash in DB)
  → Set resetPasswordExpires (1h)
  → EmailAdapter.send() → link: {CLIENT_URL}/reset-password?token=xxx

POST /auth/reset-password → body: { token, newPassword }
  → Hash incoming token with SHA-256
  → Find user with matching hash + non-expired
  → Hash new password (bcrypt via model pre-save hook)
  → Clear resetPasswordToken + resetPasswordExpires
  → Clear all refreshTokens (force re-login on all devices)
```

**Uses existing model fields:** `resetPasswordToken`, `resetPasswordExpires` (already in User model).

**Security:**
- Tokens are single-use (cleared after use)
- Tokens hashed in DB (SHA-256) — not stored in plaintext
- Always respond 200 on request (prevent email enumeration)
- Rate limited: 10 requests/min on auth endpoints

### 3.3 File Upload (Chunked)

**3-phase chunked upload for files up to 100MB:**

**Phase 1: Initialize**

```
POST /api/v1/upload/init
  Auth: required (any role)
  Body: { filename, contentType, totalSize }
  Response: { uploadId, chunkSize: 5242880, totalChunks, expiresAt }
```

**Phase 2: Upload Chunks**

```
PUT /api/v1/upload/:uploadId/chunk/:index
  Auth: required (same user who initiated)
  Body: binary chunk data
  Response: { uploaded: index, totalChunks, progress: "3/20" }
```

**Phase 3: Complete**

```
POST /api/v1/upload/:uploadId/complete
  Auth: required (same user who initiated)
  Response: { fileId, fileUrl, filename, contentType, size, createdAt }
```

**Cancel:**

```
DELETE /api/v1/upload/:uploadId
  Auth: required (same user or admin)
  Response: { success: true }
```

**Limits:**

| Parameter | Value |
|-----------|-------|
| Max file size | 100 MB |
| Chunk size | 5 MB |
| Allowed MIME types | image/*, video/*, application/pdf, application/msword, application/vnd.openxmlformats-officedocument.* |
| Max concurrent uploads/user | 3 |
| Upload session timeout | 1 hour |

**Storage:** Uses `StorageAdapter` interface. `LocalStorageAdapter` stores chunks in `./uploads/tmp/{uploadId}/` during upload, assembles to `./uploads/{fileId}` on complete.

**Upload session tracking:** In-memory Map (like rate limiter). Sessions expire after 1 hour and auto-cleanup incomplete chunks.

### 3.4 WebSocket

**Architecture: Connection Manager + Room Pattern**

**Endpoint:**

```
GET /api/v1/ws?token=<jwt>
  → Upgrade to WebSocket
  → Validate JWT from query param
  → Register connection in WsManager
  → Invalid/expired token → close(4001, 'Unauthorized')
```

**Connection Manager (`src/ws/manager.ts`):**

```typescript
class WsManager {
  private connections: Map<string, WebSocket>       // userId → ws
  private rooms: Map<string, Set<string>>           // roomId → Set<userId>
  private userRooms: Map<string, Set<string>>       // userId → Set<roomId>

  addConnection(userId: string, ws: WebSocket): void
  removeConnection(userId: string): void
  joinRoom(userId: string, roomId: string): void
  leaveRoom(userId: string, roomId: string): void
  broadcast(roomId: string, message: WsMessage): void
  sendTo(userId: string, message: WsMessage): void
  broadcastAll(message: WsMessage): void
  getRoomMembers(roomId: string): string[]
  getUserRooms(userId: string): string[]
}
```

**Message Protocol:**

Client → Server:

| Type | Payload | Description |
|------|---------|-------------|
| `join_room` | `{ roomId }` | Join a room |
| `leave_room` | `{ roomId }` | Leave a room |
| `chat_message` | `{ roomId, content }` | Send message to room |
| `ping` | — | Keepalive |

Server → Client:

| Type | Payload | Description |
|------|---------|-------------|
| `room_joined` | `{ roomId, members[] }` | Confirm room join |
| `room_left` | `{ roomId }` | Confirm room leave |
| `chat_message` | `{ roomId, from, content, timestamp }` | Chat message |
| `notification` | `{ title, body, data? }` | Push notification |
| `user_joined` | `{ roomId, userId }` | User joined room |
| `user_left` | `{ roomId, userId }` | User left room |
| `pong` | — | Keepalive response |
| `error` | `{ code, message }` | Error |

**Heartbeat:** Server sends `ping` every 30s. Client must respond within 10s or connection is closed.

**Rate limiting:** Messages rate limited at 60/min per user (in-memory, separate from HTTP rate limiter).

---

## Directory Structure (new/modified files)

```
src/
  middleware/
    auth.ts              # EXISTING
    errorHandler.ts      # EXISTING
    requestId.ts         # EXISTING
    requestLogger.ts     # EXISTING
    rbac.ts              # NEW — requireRole(), requireRoles()
    rateLimiter.ts       # NEW — sliding window + RateLimitStore
    validate.ts          # NEW — generic Zod validation
  schemas/
    common.schema.ts     # UPDATE — CursorPaginationSchema, PaginatedResponse
    user.schema.ts       # UPDATE — UserQuerySchema (search/filter params)
    auth.schema.ts       # UPDATE — VerifyEmail, RequestReset, ResetPassword schemas
    upload.schema.ts     # NEW — InitUpload, ChunkUpload, CompleteUpload
    ws.schema.ts         # NEW — WebSocket message schemas
  services/
    auth.service.ts      # UPDATE — verifyEmail, requestPasswordReset, resetPassword
    user.service.ts      # UPDATE — findAll with pagination + filters
    upload.service.ts    # NEW — chunked upload orchestration
  routes/
    auth.routes.ts       # UPDATE — verify-email, resend-verification, request-reset, reset-password
    user.routes.ts       # UPDATE — pagination, search query params
    upload.routes.ts     # NEW — init, chunk, complete, cancel endpoints
    ws.routes.ts         # NEW — WebSocket upgrade endpoint
  ws/                    # NEW — WebSocket subsystem
    manager.ts           # WsManager class
    handlers.ts          # Message type handlers
    auth.ts              # WebSocket JWT validation
  utils/
    errors.ts            # UPDATE — RateLimitError, UploadError
    query-builder.ts     # NEW — buildMongoFilter utility
    pagination.ts        # NEW — paginateQuery utility
    crypto.ts            # NEW — token generation + SHA-256 hashing
```

## New Environment Variables

```
# Rate Limiting (optional, with defaults)
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=100

# Upload (optional, with defaults)
UPLOAD_MAX_SIZE_BYTES=104857600       # 100MB
UPLOAD_CHUNK_SIZE_BYTES=5242880       # 5MB
UPLOAD_SESSION_TIMEOUT_MS=3600000     # 1h
UPLOAD_MAX_CONCURRENT=3

# WebSocket (optional, with defaults)
WS_HEARTBEAT_INTERVAL_MS=30000
WS_HEARTBEAT_TIMEOUT_MS=10000
WS_MESSAGE_RATE_LIMIT=60             # messages/min
```

## Testing Strategy

Each feature includes unit tests following existing patterns:

- **Middleware tests:** Isolated with mock Hono context
- **Schema tests:** Zod parse/safeParse validation + fast-check property tests
- **Service tests:** Require MongoDB (integration tests in CI with service container)
- **WebSocket tests:** Mock WebSocket connections
- **Upload tests:** Mock StorageAdapter

Target: Maintain 60/40/50/60 coverage thresholds (stmts/branches/funcs/lines).

## MCP Updates

The `/api/v1/mcp` endpoint will be updated with new tools:
- `upload_init`, `upload_chunk`, `upload_complete`
- `user_list` (with pagination/filter params)
- `auth_verify_email`, `auth_request_reset`, `auth_reset_password`
- `ws_connect` (with room operations documented)
