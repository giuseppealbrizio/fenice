# M3.1 Two-Phase Builder Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Split the AI Builder into a two-phase pipeline (Plan → Approve → Generate) with editable manifest, glowy loading bar, context reduction, and job timeout.

**Architecture:** Single job traverses two phases. `POST /builder/generate` stops at `plan_ready`. User reviews/edits manifest in the prompt bar. `POST /builder/jobs/:id/approve` resumes generation with the approved plan as a binding constraint. New `reject` endpoint for cancellation.

**Tech Stack:** Hono + Zod v4 + Mongoose 9 (server), React 19 + Zustand 5 (client), Claude API (planning + generation), WebSocket deltas for real-time progress.

**Design doc:** `docs/plans/2026-02-23-m3.1-sprint-design.md`

---

## Batch 1: Server Schemas + Model (plumbing)

### Task 1: Extend builder status enum and add plan schemas

**Files:**
- Modify: `src/schemas/builder.schema.ts:3-12` (status enum), `src/schemas/builder.schema.ts:34-40` (job result)
- Test: `tests/unit/schemas/builder.schema.test.ts`

**Step 1: Write failing tests for new statuses and plan schema**

Add to `tests/unit/schemas/builder.schema.test.ts`:

```typescript
// Inside "BuilderJobStatusEnum" describe (after line 33)
it('accepts planning status', () => {
  expect(BuilderJobStatusEnum.safeParse('planning').success).toBe(true);
});

it('accepts plan_ready status', () => {
  expect(BuilderJobStatusEnum.safeParse('plan_ready').success).toBe(true);
});

it('accepts rejected status', () => {
  expect(BuilderJobStatusEnum.safeParse('rejected').success).toBe(true);
});
```

Add new describe blocks for `BuilderPlanFileSchema` and `BuilderPlanSchema`:

```typescript
describe('BuilderPlanFileSchema', () => {
  it('accepts valid plan file', () => {
    const result = BuilderPlanFileSchema.safeParse({
      path: 'src/schemas/product.schema.ts',
      type: 'schema',
      action: 'create',
      description: 'Zod schema for Product',
    });
    expect(result.success).toBe(true);
  });

  it('rejects invalid type', () => {
    const result = BuilderPlanFileSchema.safeParse({
      path: 'src/foo.ts',
      type: 'controller',
      action: 'create',
      description: 'Bad type',
    });
    expect(result.success).toBe(false);
  });

  it('rejects invalid action', () => {
    const result = BuilderPlanFileSchema.safeParse({
      path: 'src/foo.ts',
      type: 'schema',
      action: 'delete',
      description: 'Bad action',
    });
    expect(result.success).toBe(false);
  });
});

describe('BuilderPlanSchema', () => {
  it('accepts valid plan', () => {
    const result = BuilderPlanSchema.safeParse({
      files: [
        { path: 'src/schemas/product.schema.ts', type: 'schema', action: 'create', description: 'Schema' },
      ],
      summary: 'Generate a product CRUD API',
    });
    expect(result.success).toBe(true);
  });

  it('rejects empty files array', () => {
    const result = BuilderPlanSchema.safeParse({
      files: [],
      summary: 'Empty plan',
    });
    expect(result.success).toBe(false);
  });

  it('rejects missing summary', () => {
    const result = BuilderPlanSchema.safeParse({
      files: [{ path: 'src/foo.ts', type: 'schema', action: 'create', description: 'X' }],
    });
    expect(result.success).toBe(false);
  });
});

describe('BuilderApproveSchema', () => {
  it('accepts valid approve body', () => {
    const result = BuilderApproveSchema.safeParse({
      plan: {
        files: [
          { path: 'src/schemas/product.schema.ts', type: 'schema', action: 'create', description: 'Schema' },
        ],
        summary: 'Generate product API',
      },
    });
    expect(result.success).toBe(true);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run tests/unit/schemas/builder.schema.test.ts`
Expected: FAIL — `BuilderPlanFileSchema`, `BuilderPlanSchema`, `BuilderApproveSchema` not found; new statuses rejected.

**Step 3: Implement schema changes**

In `src/schemas/builder.schema.ts`:

Add 3 new statuses to `BuilderJobStatusEnum` (line 3-12):
```typescript
export const BuilderJobStatusEnum = z.enum([
  'queued',
  'planning',
  'plan_ready',
  'reading_context',
  'generating',
  'writing_files',
  'validating',
  'creating_pr',
  'completed',
  'failed',
  'rejected',
]);
```

Add new schemas after `BuilderPromptSchema` (after line 26):
```typescript
export const BuilderPlanFileTypeEnum = z.enum(['schema', 'model', 'service', 'route', 'test']);

export const BuilderPlanFileSchema = z.object({
  path: z.string().min(1),
  type: BuilderPlanFileTypeEnum,
  action: z.enum(['create', 'modify']),
  description: z.string().min(1).max(500),
});

export const BuilderPlanSchema = z.object({
  files: z.array(BuilderPlanFileSchema).min(1),
  summary: z.string().min(1).max(1000),
});

export const BuilderApproveSchema = z.object({
  plan: BuilderPlanSchema,
});
```

Add `plan` to `BuilderJobResultSchema` (line 34):
```typescript
export const BuilderJobResultSchema = z.object({
  files: z.array(BuilderGeneratedFileSchema),
  prUrl: z.string().optional(),
  prNumber: z.number().int().positive().optional(),
  branch: z.string().optional(),
  validationPassed: z.boolean().optional(),
});
```
(No change needed — plan is stored separately on the job, not in result.)

Add `plan` field to `BuilderJobSchema` (line 48):
```typescript
export const BuilderJobSchema = z.object({
  id: z.string(),
  prompt: z.string(),
  status: BuilderJobStatusEnum,
  options: BuilderOptionsSchema.optional(),
  plan: BuilderPlanSchema.optional(),
  result: BuilderJobResultSchema.optional(),
  error: BuilderJobErrorSchema.optional(),
  userId: z.string(),
  createdAt: z.iso.datetime(),
  updatedAt: z.iso.datetime(),
});
```

Add type exports at the bottom:
```typescript
export type BuilderPlanFileType = z.infer<typeof BuilderPlanFileTypeEnum>;
export type BuilderPlanFile = z.infer<typeof BuilderPlanFileSchema>;
export type BuilderPlan = z.infer<typeof BuilderPlanSchema>;
export type BuilderApprove = z.infer<typeof BuilderApproveSchema>;
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run tests/unit/schemas/builder.schema.test.ts`
Expected: PASS (all existing + new tests)

**Step 5: Commit**

```bash
git add src/schemas/builder.schema.ts tests/unit/schemas/builder.schema.test.ts
git commit -m "feat(builder): add plan schemas and new pipeline statuses"
```

---

### Task 2: Add plan field to Mongoose model

**Files:**
- Modify: `src/models/builder-job.model.ts:38-75`

**Step 1: Add plan sub-schema and field**

After the `jobErrorSchema` (line 36) in `src/models/builder-job.model.ts`, add:

```typescript
const planFileSchema = new Schema(
  {
    path: { type: String, required: true },
    type: { type: String, required: true, enum: ['schema', 'model', 'service', 'route', 'test'] },
    action: { type: String, required: true, enum: ['create', 'modify'] },
    description: { type: String, required: true },
  },
  { _id: false }
);

const planSchema = new Schema(
  {
    files: { type: [planFileSchema], required: true },
    summary: { type: String, required: true },
  },
  { _id: false }
);
```

Add `plan` field to the main schema (in the fields object around line 38-65):
```typescript
plan: { type: planSchema, default: undefined },
```

Update the `status` enum to include new values:
```typescript
status: {
  type: String,
  required: true,
  enum: ['queued', 'planning', 'plan_ready', 'reading_context', 'generating', 'writing_files', 'validating', 'creating_pr', 'completed', 'failed', 'rejected'],
  default: 'queued',
},
```

**Step 2: Run typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 3: Commit**

```bash
git add src/models/builder-job.model.ts
git commit -m "feat(builder): add plan field and new statuses to job model"
```

---

### Task 3: Update world-delta schema and notifier

**Files:**
- Modify: `src/schemas/world-delta.schema.ts:74-83`
- Modify: `src/services/builder/world-notifier.ts:8-17`

**Step 1: Add new statuses to world-delta schema**

The `BuilderProgressEventSchema` at line 74-83 of `src/schemas/world-delta.schema.ts` uses `BuilderJobStatusEnum` which was already updated in Task 1. No schema change needed here — it picks up the enum automatically.

**Step 2: Update STATUS_MESSAGES in world-notifier**

In `src/services/builder/world-notifier.ts`, update `STATUS_MESSAGES` (lines 8-17):

```typescript
const STATUS_MESSAGES: Record<BuilderJobStatus, string> = {
  queued: 'Job queued',
  planning: 'Analyzing prompt and creating file plan',
  plan_ready: 'Plan ready for review',
  reading_context: 'Reading project context',
  generating: 'Generating code via Claude API',
  writing_files: 'Writing generated files to disk',
  validating: 'Running validation (lint + typecheck + test)',
  creating_pr: 'Creating pull request on GitHub',
  completed: 'Pipeline completed successfully',
  failed: 'Pipeline failed',
  rejected: 'Plan rejected by user',
};
```

**Step 3: Run typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 4: Run existing tests**

Run: `npx vitest run tests/unit/schemas/world-delta.schema.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/schemas/world-delta.schema.ts src/services/builder/world-notifier.ts
git commit -m "feat(builder): add planning/plan_ready/rejected to delta schema and notifier"
```

---

## Batch 2: Planning Phase (server)

### Task 4: Add plan generation prompt template

**Files:**
- Modify: `src/services/builder/prompt-templates.ts`

**Step 1: Add BUILDER_PLAN_PROMPT**

After `BUILDER_TOOLS` (line 189) in `src/services/builder/prompt-templates.ts`, add:

```typescript
export const BUILDER_PLAN_PROMPT = `You are an expert backend architect analyzing a code generation request for the FENICE API platform.

Your job is to produce a structured JSON plan of files that need to be created or modified — NOT the code itself.

## Project Structure

Files follow these conventions:
- Schema: src/schemas/<name>.schema.ts (Zod schemas + types)
- Model: src/models/<name>.model.ts (Mongoose schema + model)
- Service: src/services/<name>.service.ts (Business logic)
- Route: src/routes/<name>.routes.ts (OpenAPI route handlers)
- Test: tests/unit/schemas/<name>.schema.test.ts (Schema tests)

## Instructions

1. Analyze the user's request and the project context provided
2. Determine which files need to be created or modified
3. Output ONLY a JSON object with this exact structure:

{
  "summary": "1-2 sentence description of what will be generated",
  "files": [
    {
      "path": "src/schemas/example.schema.ts",
      "type": "schema",
      "action": "create",
      "description": "What this file will contain"
    }
  ]
}

Rules:
- type must be one of: schema, model, service, route, test
- action must be one of: create, modify
- Only include files in src/schemas/, src/models/, src/services/, src/routes/, tests/
- Follow the project's kebab-case naming convention
- Generate files in dependency order: schema → model → service → route → test
- Output ONLY the JSON object, no markdown fences, no explanation
`;
```

**Step 2: Add plan constraint template function**

```typescript
export function buildPlanConstraint(plan: { files: { path: string; action: string; description: string }[] }): string {
  const lines = plan.files
    .map((f, i) => `${i + 1}. ${f.path} (${f.action}) — ${f.description}`)
    .join('\n');

  return `## Approved Plan — generate ONLY these files

${lines}

IMPORTANT:
- Do NOT create files outside this plan.
- Do NOT skip any file in this plan.
- Generate each file completely, following project conventions.
`;
}
```

**Step 3: Run typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 4: Commit**

```bash
git add src/services/builder/prompt-templates.ts
git commit -m "feat(builder): add plan generation prompt and constraint template"
```

---

### Task 5: Add generatePlan function to code-generator

**Files:**
- Modify: `src/services/builder/code-generator.ts`
- Test: `tests/unit/services/builder/code-generator.test.ts` (new file if not exists, or add to existing)

**Step 1: Write test for generatePlan**

Check if test file exists first. Create `tests/unit/services/builder/code-generator.test.ts` if needed:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';

// Mock Anthropic SDK
const mockCreate = vi.fn();
vi.mock('@anthropic-ai/sdk', () => ({
  default: vi.fn().mockImplementation(() => ({
    messages: { create: mockCreate },
  })),
}));

import { generatePlan } from '../../../../src/services/builder/code-generator.js';
import type { ContextBundle } from '../../../../src/services/builder/context-reader.js';

const mockContext: ContextBundle = {
  openApiSpec: '{}',
  projectConventions: 'conventions',
  exampleSchema: 'schema',
  exampleModel: 'model',
  exampleService: 'service',
  exampleRoute: 'route',
};

describe('generatePlan', () => {
  beforeEach(() => {
    mockCreate.mockReset();
  });

  it('returns parsed plan from Claude JSON response', async () => {
    const plan = {
      summary: 'Generate a product CRUD API',
      files: [
        { path: 'src/schemas/product.schema.ts', type: 'schema', action: 'create', description: 'Zod schema' },
        { path: 'src/models/product.model.ts', type: 'model', action: 'create', description: 'Mongoose model' },
      ],
    };

    mockCreate.mockResolvedValueOnce({
      content: [{ type: 'text', text: JSON.stringify(plan) }],
      usage: { input_tokens: 500, output_tokens: 100 },
    });

    const result = await generatePlan('Create a product CRUD', mockContext, 'test-api-key');
    expect(result.plan.summary).toBe('Generate a product CRUD API');
    expect(result.plan.files).toHaveLength(2);
    expect(result.plan.files[0]?.type).toBe('schema');
    expect(result.tokenUsage.inputTokens).toBe(500);
  });

  it('throws on invalid JSON response', async () => {
    mockCreate.mockResolvedValueOnce({
      content: [{ type: 'text', text: 'This is not JSON' }],
      usage: { input_tokens: 100, output_tokens: 50 },
    });

    await expect(generatePlan('Create something', mockContext, 'key')).rejects.toThrow('PLAN_PARSE_ERROR');
  });

  it('throws on plan that fails schema validation', async () => {
    mockCreate.mockResolvedValueOnce({
      content: [{ type: 'text', text: JSON.stringify({ summary: 'x', files: [] }) }],
      usage: { input_tokens: 100, output_tokens: 50 },
    });

    await expect(generatePlan('Create something', mockContext, 'key')).rejects.toThrow('PLAN_PARSE_ERROR');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run tests/unit/services/builder/code-generator.test.ts`
Expected: FAIL — `generatePlan` not exported

**Step 3: Implement generatePlan**

In `src/services/builder/code-generator.ts`, add after imports (around line 14):

```typescript
import { BUILDER_PLAN_PROMPT } from './prompt-templates.js';
import { BuilderPlanSchema } from '../../schemas/builder.schema.js';
import type { BuilderPlan } from '../../schemas/builder.schema.js';
```

Add new interface and function (before `generateCode`):

```typescript
export interface PlanResult {
  plan: BuilderPlan;
  tokenUsage: { inputTokens: number; outputTokens: number };
}

export async function generatePlan(
  prompt: string,
  context: ContextBundle,
  apiKey: string
): Promise<PlanResult> {
  const client = new Anthropic({ apiKey });

  const contextText = formatContextForPrompt(context);
  const userMessage = `${contextText}\n\n## User Request\n\n${prompt}`;

  let response: Anthropic.Message;
  try {
    response = await client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1024,
      system: BUILDER_PLAN_PROMPT,
      messages: [{ role: 'user', content: userMessage }],
    });
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : 'Unknown Anthropic API error';
    logger.error({ error: message }, 'Anthropic API call failed during planning');
    throw new AppError(502, 'LLM_API_ERROR', `Claude API error during planning: ${message}`);
  }

  const textBlock = response.content.find((b) => b.type === 'text');
  const raw = textBlock?.type === 'text' ? textBlock.text : '';

  let parsed: unknown;
  try {
    parsed = JSON.parse(raw);
  } catch {
    logger.error({ raw: raw.slice(0, 200) }, 'Plan response is not valid JSON');
    throw new AppError(502, 'PLAN_PARSE_ERROR', 'Claude returned invalid JSON for the plan');
  }

  const validation = BuilderPlanSchema.safeParse(parsed);
  if (!validation.success) {
    logger.error({ issues: validation.error.issues }, 'Plan response failed schema validation');
    throw new AppError(502, 'PLAN_PARSE_ERROR', 'Claude returned a plan that does not match the expected schema');
  }

  return {
    plan: validation.data,
    tokenUsage: {
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens,
    },
  };
}
```

**Step 4: Update generateCode to accept plan constraint**

Modify the `generateCode` function signature (line 27) to accept an optional plan:

```typescript
export async function generateCode(
  prompt: string,
  context: ContextBundle,
  projectRoot: string,
  apiKey: string,
  onToolActivity?: ToolActivityCallback,
  plan?: BuilderPlan
): Promise<GenerationResult>
```

Update the `userMessage` construction (line 37) to prepend the plan constraint:

```typescript
import { buildPlanConstraint } from './prompt-templates.js';

// Inside generateCode:
const planConstraint = plan ? buildPlanConstraint(plan) : '';
const userMessage = `${contextText}\n\n${planConstraint}## User Request\n\n${prompt}\n\nGenerate all necessary files using the tools provided. Create complete, production-ready code following the project conventions shown above.`;
```

**Step 5: Run tests**

Run: `npx vitest run tests/unit/services/builder/code-generator.test.ts`
Expected: PASS

**Step 6: Run full typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 7: Commit**

```bash
git add src/services/builder/code-generator.ts tests/unit/services/builder/code-generator.test.ts
git commit -m "feat(builder): add generatePlan function and plan constraint in generateCode"
```

---

### Task 6: Split builder service pipeline into two phases

**Files:**
- Modify: `src/services/builder.service.ts:27-42` (generate), `src/services/builder.service.ts:133-292` (executePipeline)

**Step 1: Split executePipeline into executePlanning + executeGeneration**

In `src/services/builder.service.ts`:

1. Import `generatePlan` and `BuilderPlan`:
```typescript
import { generateCode, repairCode, generatePlan } from './builder/code-generator.js';
import type { BuilderPlan } from '../schemas/builder.schema.js';
```

2. Modify `generate` method to call `executePlanning` instead of `executePipeline`:
```typescript
async generate(
  prompt: string,
  userId: string,
  options?: BuilderOptions
): Promise<BuilderJobDocument> {
  const job = await BuilderJobModel.create({
    prompt,
    userId,
    status: 'queued',
    options: options ?? { dryRun: false, includeModel: true, includeTests: true },
  });

  void this.executePlanning(job._id.toString(), prompt);

  return job;
}
```

3. Add new `approve` and `reject` methods:
```typescript
async approve(jobId: string, plan: BuilderPlan): Promise<void> {
  const job = await BuilderJobModel.findById(jobId);
  if (!job) throw new NotFoundError('Builder job not found');
  if (job.status !== 'plan_ready') {
    throw new AppError(400, 'INVALID_STATE', `Job is in '${job.status}' state, expected 'plan_ready'`);
  }

  await BuilderJobModel.findByIdAndUpdate(jobId, { plan, status: 'reading_context' });
  this.notifier?.emitProgress(jobId, 'reading_context');

  void this.executeGeneration(jobId, job.prompt, plan, job.options);
}

async reject(jobId: string): Promise<void> {
  const job = await BuilderJobModel.findById(jobId);
  if (!job) throw new NotFoundError('Builder job not found');
  if (job.status !== 'plan_ready') {
    throw new AppError(400, 'INVALID_STATE', `Job is in '${job.status}' state, expected 'plan_ready'`);
  }

  await this.updateStatus(jobId, 'rejected');
  this.notifier?.emitProgress(jobId, 'rejected');
}
```

4. Add `executePlanning` (replaces the first part of the old pipeline):
```typescript
private async executePlanning(jobId: string, prompt: string): Promise<void> {
  try {
    await this.updateStatus(jobId, 'planning');
    this.notifier?.emitProgress(jobId, 'planning');

    const projectRoot = this.getProjectRoot();
    const context = await buildContextBundle(projectRoot);
    const apiKey = this.getApiKey();

    const { plan } = await generatePlan(prompt, context, apiKey);
    logger.info({ jobId, fileCount: plan.files.length }, 'Plan generated');

    await BuilderJobModel.findByIdAndUpdate(jobId, { plan, status: 'plan_ready' });
    this.notifier?.emitProgress(jobId, 'plan_ready');
  } catch (err: unknown) {
    const message = err instanceof Error ? err.message : 'Unknown error';
    const code = err instanceof AppError ? err.code : 'PLANNING_ERROR';
    logger.error({ jobId, error: message }, 'Planning failed');
    await this.updateStatus(jobId, 'failed', {
      error: { code, message, step: 'planning' },
    });
    this.notifier?.emitProgress(jobId, 'failed');
  }
}
```

5. Rename `executePipeline` to `executeGeneration` and modify it to accept a plan parameter. Remove the planning/context reading from the beginning (it's already done). The method starts at `reading_context` and injects the plan:

```typescript
private async executeGeneration(
  jobId: string,
  prompt: string,
  plan: BuilderPlan,
  options?: BuilderOptions
): Promise<void> {
  const isDryRun = options?.dryRun === true;
  let currentStep: BuilderJobStatus = 'reading_context';

  try {
    // Step 1: Read context
    const projectRoot = this.getProjectRoot();
    const context = await buildContextBundle(projectRoot);
    logger.info({ jobId }, 'Context bundle built');

    // Step 2: Generate code with plan constraint
    currentStep = 'generating';
    await this.updateStatus(jobId, currentStep);
    this.notifier?.emitProgress(jobId, currentStep);
    const apiKey = this.getApiKey();
    const notifier = this.notifier;
    const onToolActivity = notifier
      ? (tool: string, path: string): void => {
          notifier.emitToolActivity(jobId, tool, path);
        }
      : undefined;
    const result = await generateCode(prompt, context, projectRoot, apiKey, onToolActivity, plan);
    logger.info(
      { jobId, fileCount: result.files.length, violations: result.violations.length },
      'Code generation complete'
    );

    // ... rest of pipeline unchanged (scope check, dry run, write files, validate, PR) ...
```

The rest of the pipeline (lines 167-291 of the original) stays the same.

**Step 2: Run typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 3: Run existing integration tests**

Run: `npx vitest run tests/integration/builder.test.ts`
Expected: PASS (tests mock the model, pipeline is fire-and-forget)

**Step 4: Commit**

```bash
git add src/services/builder.service.ts
git commit -m "feat(builder): split pipeline into planning and generation phases"
```

---

### Task 7: Add approve and reject routes

**Files:**
- Modify: `src/routes/builder.routes.ts`
- Modify: `tests/integration/builder.test.ts`

**Step 1: Write failing integration tests**

Add to `tests/integration/builder.test.ts`:

```typescript
describe('POST /api/v1/builder/jobs/:id/approve', () => {
  it('returns 503 when builder is disabled', async () => {
    process.env['BUILDER_ENABLED'] = 'false';
    const app = await createTestApp();
    const res = await app.request('/api/v1/builder/jobs/abc123/approve', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer test' },
      body: JSON.stringify({
        plan: {
          files: [{ path: 'src/schemas/x.schema.ts', type: 'schema', action: 'create', description: 'X' }],
          summary: 'Test',
        },
      }),
    });
    expect(res.status).toBe(503);
  });

  it('returns 403 when role is user', async () => {
    process.env['BUILDER_ENABLED'] = 'true';
    const app = await createTestApp('user');
    const res = await app.request('/api/v1/builder/jobs/abc123/approve', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer test' },
      body: JSON.stringify({
        plan: {
          files: [{ path: 'src/schemas/x.schema.ts', type: 'schema', action: 'create', description: 'X' }],
          summary: 'Test',
        },
      }),
    });
    expect(res.status).toBe(403);
  });

  it('returns 400 when plan is invalid', async () => {
    process.env['BUILDER_ENABLED'] = 'true';
    const app = await createTestApp();
    const res = await app.request('/api/v1/builder/jobs/abc123/approve', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer test' },
      body: JSON.stringify({ plan: { files: [], summary: '' } }),
    });
    expect(res.status).toBe(400);
  });
});

describe('POST /api/v1/builder/jobs/:id/reject', () => {
  it('returns 503 when builder is disabled', async () => {
    process.env['BUILDER_ENABLED'] = 'false';
    const app = await createTestApp();
    const res = await app.request('/api/v1/builder/jobs/abc123/reject', {
      method: 'POST',
      headers: { Authorization: 'Bearer test' },
    });
    expect(res.status).toBe(503);
  });

  it('returns 403 when role is user', async () => {
    process.env['BUILDER_ENABLED'] = 'true';
    const app = await createTestApp('user');
    const res = await app.request('/api/v1/builder/jobs/abc123/reject', {
      method: 'POST',
      headers: { Authorization: 'Bearer test' },
    });
    expect(res.status).toBe(403);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run tests/integration/builder.test.ts`
Expected: FAIL — routes don't exist yet

**Step 3: Implement routes**

In `src/routes/builder.routes.ts`, add new route definitions (after `listJobsRoute`):

```typescript
import { BuilderApproveSchema } from '../schemas/builder.schema.js';

const approveRoute = createRoute({
  method: 'post',
  path: '/builder/jobs/{id}/approve',
  tags: ['Builder'],
  summary: 'Approve a builder plan and start code generation',
  security: [{ Bearer: [] }],
  request: {
    params: z.object({ id: z.string().min(1) }),
    body: {
      content: { 'application/json': { schema: BuilderApproveSchema } },
      required: true,
    },
  },
  responses: {
    200: {
      description: 'Plan approved, generation started',
      content: { 'application/json': { schema: z.object({ status: z.literal('generating') }) } },
    },
    400: { description: 'Invalid state or body', content: { 'application/json': { schema: ErrorResponseSchema } } },
    401: { description: 'Not authenticated', content: { 'application/json': { schema: ErrorResponseSchema } } },
    403: { description: 'Forbidden', content: { 'application/json': { schema: ErrorResponseSchema } } },
    404: { description: 'Job not found', content: { 'application/json': { schema: ErrorResponseSchema } } },
    503: { description: 'Builder disabled', content: { 'application/json': { schema: ErrorResponseSchema } } },
  },
});

const rejectRoute = createRoute({
  method: 'post',
  path: '/builder/jobs/{id}/reject',
  tags: ['Builder'],
  summary: 'Reject a builder plan',
  security: [{ Bearer: [] }],
  request: {
    params: z.object({ id: z.string().min(1) }),
  },
  responses: {
    200: {
      description: 'Plan rejected',
      content: { 'application/json': { schema: z.object({ status: z.literal('rejected') }) } },
    },
    400: { description: 'Invalid state', content: { 'application/json': { schema: ErrorResponseSchema } } },
    401: { description: 'Not authenticated', content: { 'application/json': { schema: ErrorResponseSchema } } },
    403: { description: 'Forbidden', content: { 'application/json': { schema: ErrorResponseSchema } } },
    404: { description: 'Job not found', content: { 'application/json': { schema: ErrorResponseSchema } } },
    503: { description: 'Builder disabled', content: { 'application/json': { schema: ErrorResponseSchema } } },
  },
});
```

Add RBAC middleware and handlers:
```typescript
builderRouter.post('/builder/jobs/:id/approve', requireRole('admin'));
builderRouter.post('/builder/jobs/:id/reject', requireRole('admin'));

builderRouter.openapi(approveRoute, async (c) => {
  checkBuilderEnabled();
  const { id } = c.req.valid('param');
  const { plan } = c.req.valid('json');
  await getBuilderService().approve(id, plan);
  return c.json({ status: 'generating' as const }, 200);
});

builderRouter.openapi(rejectRoute, async (c) => {
  checkBuilderEnabled();
  const { id } = c.req.valid('param');
  await getBuilderService().reject(id);
  return c.json({ status: 'rejected' as const }, 200);
});
```

**Step 4: Run tests**

Run: `npx vitest run tests/integration/builder.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/routes/builder.routes.ts tests/integration/builder.test.ts
git commit -m "feat(builder): add approve and reject endpoints"
```

---

### Task 8: Add job timeout (10 min TTL)

**Files:**
- Modify: `src/services/builder.service.ts`

**Step 1: Add timeout wrapper**

In `builder.service.ts`, add a utility at the top of the file:

```typescript
const PIPELINE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes

function withTimeout<T>(promise: Promise<T>, ms: number, label: string): Promise<T> {
  return new Promise<T>((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new AppError(408, 'TIMEOUT', `${label} timed out after ${ms / 1000}s`));
    }, ms);
    promise.then(resolve, reject).finally(() => clearTimeout(timer));
  });
}
```

**Step 2: Wrap executePlanning and executeGeneration**

In `executePlanning`, wrap the `generatePlan` call:
```typescript
const { plan } = await withTimeout(
  generatePlan(prompt, context, apiKey),
  PIPELINE_TIMEOUT_MS,
  'Planning'
);
```

In `executeGeneration`, wrap the `generateCode` call:
```typescript
const result = await withTimeout(
  generateCode(prompt, context, projectRoot, apiKey, onToolActivity, plan),
  PIPELINE_TIMEOUT_MS,
  'Code generation'
);
```

**Step 3: Run typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 4: Commit**

```bash
git add src/services/builder.service.ts
git commit -m "feat(builder): add 10-minute timeout guard on pipeline phases"
```

---

## Batch 3: Client — Types, Store, API

### Task 9: Update client-side builder types

**Files:**
- Modify: `client/src/types/builder.ts`

**Step 1: Add new types**

Update `BuilderJobStatus` to include new statuses:
```typescript
export type BuilderJobStatus =
  | 'queued'
  | 'planning'
  | 'plan_ready'
  | 'reading_context'
  | 'generating'
  | 'writing_files'
  | 'validating'
  | 'creating_pr'
  | 'completed'
  | 'failed'
  | 'rejected';
```

Add new interfaces:
```typescript
export type BuilderPlanFileType = 'schema' | 'model' | 'service' | 'route' | 'test';

export interface BuilderPlanFile {
  path: string;
  type: BuilderPlanFileType;
  action: 'create' | 'modify';
  description: string;
}

export interface BuilderPlan {
  files: BuilderPlanFile[];
  summary: string;
}
```

Add `plan` to `BuilderJob`:
```typescript
export interface BuilderJob {
  id: string;
  prompt: string;
  status: BuilderJobStatus;
  plan?: BuilderPlan | undefined;
  result?: BuilderJobResult | undefined;
  error?: BuilderJobError | undefined;
  userId: string;
  createdAt: string;
  updatedAt: string;
}
```

**Step 2: Run client typecheck**

Run: `cd client && npx tsc --noEmit`
Expected: PASS (or may need fixes in store/component — fix in next tasks)

**Step 3: Commit**

```bash
git add client/src/types/builder.ts
git commit -m "feat(builder): add plan types and new statuses to client"
```

---

### Task 10: Update builder store with plan actions

**Files:**
- Modify: `client/src/stores/builder.store.ts`
- Test: `client/src/__tests__/builder.store.test.ts`

**Step 1: Write failing tests**

Add to `client/src/__tests__/builder.store.test.ts`:

```typescript
describe('plan actions', () => {
  it('setPlan stores plan and summary', () => {
    const { startJob, setPlan } = useBuilderStore.getState();
    startJob('job-1');
    const plan = [
      { path: 'src/schemas/product.schema.ts', type: 'schema' as const, action: 'create' as const, description: 'Schema' },
    ];
    setPlan(plan, 'Generate product API');
    const state = useBuilderStore.getState();
    expect(state.plan).toEqual(plan);
    expect(state.summary).toBe('Generate product API');
  });

  it('updatePlanFile modifies a file entry', () => {
    const { startJob, setPlan, updatePlanFile } = useBuilderStore.getState();
    startJob('job-1');
    const plan = [
      { path: 'src/schemas/product.schema.ts', type: 'schema' as const, action: 'create' as const, description: 'Old' },
    ];
    setPlan(plan, 'Summary');
    updatePlanFile(0, { description: 'New description' });
    expect(useBuilderStore.getState().plan![0]!.description).toBe('New description');
  });

  it('removePlanFile removes a file entry', () => {
    const { startJob, setPlan, removePlanFile } = useBuilderStore.getState();
    startJob('job-1');
    const plan = [
      { path: 'a.ts', type: 'schema' as const, action: 'create' as const, description: 'A' },
      { path: 'b.ts', type: 'model' as const, action: 'create' as const, description: 'B' },
    ];
    setPlan(plan, 'Summary');
    removePlanFile(0);
    expect(useBuilderStore.getState().plan).toHaveLength(1);
    expect(useBuilderStore.getState().plan![0]!.path).toBe('b.ts');
  });

  it('dismiss clears plan and summary', () => {
    const { startJob, setPlan, dismiss } = useBuilderStore.getState();
    startJob('job-1');
    setPlan([{ path: 'a.ts', type: 'schema' as const, action: 'create' as const, description: 'A' }], 'Summary');
    dismiss();
    const state = useBuilderStore.getState();
    expect(state.plan).toBeNull();
    expect(state.summary).toBeNull();
  });

  it('applyProgress with plan_ready triggers setPlan via REST fetch (not inline)', () => {
    const { startJob, applyProgress } = useBuilderStore.getState();
    startJob('job-1');
    applyProgress({ jobId: 'job-1', status: 'plan_ready', message: 'Plan ready' });
    const state = useBuilderStore.getState();
    expect(state.status).toBe('plan_ready');
    // Plan itself comes from REST fetch, not from delta payload
    expect(state.plan).toBeNull();
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd client && npx vitest run src/__tests__/builder.store.test.ts`
Expected: FAIL — `setPlan`, `updatePlanFile`, `removePlanFile`, `summary` don't exist

**Step 3: Implement store changes**

In `client/src/stores/builder.store.ts`:

Add imports:
```typescript
import type { BuilderPlanFile } from '../types/builder';
```

Add to `BuilderState` interface:
```typescript
plan: BuilderPlanFile[] | null;
summary: string | null;

setPlan: (plan: BuilderPlanFile[], summary: string) => void;
updatePlanFile: (index: number, changes: Partial<BuilderPlanFile>) => void;
removePlanFile: (index: number) => void;
```

Add to `initialState`:
```typescript
plan: null as BuilderPlanFile[] | null,
summary: null as string | null,
```

Add actions in create:
```typescript
setPlan: (plan, summary) => set({ plan, summary }),

updatePlanFile: (index, changes) => {
  const plan = get().plan;
  if (!plan) return;
  const updated = [...plan];
  const existing = updated[index];
  if (!existing) return;
  updated[index] = { ...existing, ...changes };
  set({ plan: updated });
},

removePlanFile: (index) => {
  const plan = get().plan;
  if (!plan) return;
  set({ plan: plan.filter((_, i) => i !== index) });
},
```

Update `dismiss` to clear plan/summary:
```typescript
dismiss: () =>
  set({ jobId: null, status: null, statusMessage: null, files: [], logs: [], error: null, plan: null, summary: null }),
```

Update `reset` initialState to include `plan: null, summary: null`.

**Step 4: Run tests**

Run: `cd client && npx vitest run src/__tests__/builder.store.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add client/src/stores/builder.store.ts client/src/__tests__/builder.store.test.ts
git commit -m "feat(builder): add plan state and edit actions to builder store"
```

---

### Task 11: Add approve/reject to builder API client

**Files:**
- Modify: `client/src/services/builder-api.ts`

**Step 1: Add new functions**

```typescript
import type { BuilderPlanFile } from '../types/builder';

export async function approveBuilderJob(
  token: string,
  jobId: string,
  plan: { files: BuilderPlanFile[]; summary: string }
): Promise<void> {
  const res = await fetch(`/api/v1/builder/jobs/${jobId}/approve`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ plan }),
  });

  if (!res.ok) {
    const body = (await res.json().catch(() => null)) as Record<string, string> | null;
    throw new Error(body?.message ?? `Approve failed (${res.status})`);
  }
}

export async function rejectBuilderJob(token: string, jobId: string): Promise<void> {
  const res = await fetch(`/api/v1/builder/jobs/${jobId}/reject`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${token}` },
  });

  if (!res.ok) {
    const body = (await res.json().catch(() => null)) as Record<string, string> | null;
    throw new Error(body?.message ?? `Reject failed (${res.status})`);
  }
}
```

**Step 2: Run client typecheck**

Run: `cd client && npx tsc --noEmit`
Expected: PASS

**Step 3: Commit**

```bash
git add client/src/services/builder-api.ts
git commit -m "feat(builder): add approve and reject API client functions"
```

---

## Batch 4: Client UI — Plan Review + Glowy Loading Bar

### Task 12: Add Plan Review section to BuilderPromptBar

**Files:**
- Modify: `client/src/components/BuilderPromptBar.tsx`

**Step 1: Update STATUS_LABELS and PROGRESS_ORDER**

Add new statuses:
```typescript
const STATUS_LABELS: Record<BuilderJobStatus, string> = {
  queued: 'Queued',
  planning: 'Creating plan...',
  plan_ready: 'Plan ready — review and approve',
  reading_context: 'Reading project context...',
  generating: 'Generating code...',
  writing_files: 'Writing files...',
  validating: 'Running validation...',
  creating_pr: 'Creating pull request...',
  completed: 'Completed',
  failed: 'Failed',
  rejected: 'Rejected',
};

const PROGRESS_ORDER: BuilderJobStatus[] = [
  'queued',
  'planning',
  'plan_ready',
  'reading_context',
  'generating',
  'writing_files',
  'validating',
  'creating_pr',
  'completed',
];
```

**Step 2: Add plan state subscriptions and handlers**

Add to the component:
```typescript
const plan = useBuilderStore((s) => s.plan);
const summary = useBuilderStore((s) => s.summary);
const setPlan = useBuilderStore((s) => s.setPlan);
const updatePlanFile = useBuilderStore((s) => s.updatePlanFile);
const removePlanFile = useBuilderStore((s) => s.removePlanFile);
```

Add approve/reject handlers:
```typescript
const handleApprove = useCallback(async () => {
  if (!jobId || !WS_TOKEN || !plan || !summary) return;
  try {
    await approveBuilderJob(WS_TOKEN, jobId, { files: plan, summary });
  } catch (err) {
    setError(err instanceof Error ? err.message : 'Approve failed');
  }
}, [jobId, plan, summary, setError]);

const handleReject = useCallback(async () => {
  if (!jobId || !WS_TOKEN) return;
  try {
    await rejectBuilderJob(WS_TOKEN, jobId);
    dismiss();
  } catch (err) {
    setError(err instanceof Error ? err.message : 'Reject failed');
  }
}, [jobId, dismiss, setError]);
```

Add useEffect to fetch plan when plan_ready:
```typescript
useEffect(() => {
  if (!jobId || !WS_TOKEN || status !== 'plan_ready') return;

  let cancelled = false;
  void fetchBuilderJob(WS_TOKEN, jobId)
    .then((job) => {
      if (cancelled || !job.plan) return;
      setPlan(job.plan.files, job.plan.summary);
    })
    .catch((err) => {
      if (cancelled) return;
      setError(err instanceof Error ? err.message : 'Failed to fetch plan');
    });

  return () => { cancelled = true; };
}, [jobId, status, setPlan, setError]);
```

**Step 3: Add Plan Review JSX**

After the progress bar section and before the activity log, add:

```tsx
{/* Plan review */}
{status === 'plan_ready' && plan && (
  <div style={{ marginBottom: '12px' }}>
    {summary && (
      <div style={{ fontSize: '12px', color: theme.text, marginBottom: '10px', lineHeight: 1.4 }}>
        {summary}
      </div>
    )}
    <div style={{
      fontSize: '10px', color: theme.muted, textTransform: 'uppercase',
      letterSpacing: '0.5px', marginBottom: '6px',
    }}>
      Files to Generate ({plan.length})
    </div>
    <div style={{ maxHeight: '200px', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '6px' }}>
      {plan.map((file, i) => (
        <div key={i} style={{
          display: 'flex', alignItems: 'center', gap: '6px', fontSize: '12px',
          padding: '6px 8px', borderRadius: '6px',
          backgroundColor: visualMode === 'dark' ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.02)',
        }}>
          <span style={{
            fontSize: '9px', fontWeight: 700, padding: '1px 5px', borderRadius: '3px',
            color: '#fff', backgroundColor: TYPE_COLORS[file.type] ?? theme.badgeCreated,
            textTransform: 'uppercase', flexShrink: 0,
          }}>
            {file.type}
          </span>
          <span style={{
            fontFamily: 'ui-monospace, "SF Mono", Menlo, monospace', fontSize: '11px',
            color: theme.text, flexShrink: 0,
          }}>
            {file.path}
          </span>
          <input
            type="text"
            value={file.description}
            onChange={(e) => updatePlanFile(i, { description: e.target.value })}
            style={{
              flex: 1, fontSize: '11px', color: theme.muted, background: 'none',
              border: 'none', outline: 'none', padding: '0 4px', minWidth: 0,
            }}
          />
          <button
            type="button"
            onClick={() => removePlanFile(i)}
            style={{
              background: 'none', border: 'none', color: theme.close,
              fontSize: '14px', cursor: 'pointer', padding: '0 2px', lineHeight: 1, flexShrink: 0,
            }}
            aria-label={`Remove ${file.path}`}
          >
            ×
          </button>
        </div>
      ))}
    </div>
    <div style={{ display: 'flex', gap: '8px', marginTop: '10px' }}>
      <button type="button" onClick={() => void handleApprove()}
        disabled={!plan || plan.length === 0}
        style={{
          flex: 1, padding: '8px 16px', borderRadius: '6px', border: 'none',
          backgroundColor: plan && plan.length > 0 ? theme.buttonBg : theme.buttonDisabled,
          color: theme.buttonText, fontSize: '12px', fontWeight: 600,
          cursor: plan && plan.length > 0 ? 'pointer' : 'not-allowed',
        }}
      >
        Approve & Generate
      </button>
      <button type="button" onClick={() => void handleReject()}
        style={{
          padding: '8px 16px', borderRadius: '6px',
          border: `1px solid ${theme.errorText}`, backgroundColor: 'transparent',
          color: theme.errorText, fontSize: '12px', fontWeight: 600, cursor: 'pointer',
        }}
      >
        Reject
      </button>
    </div>
  </div>
)}
```

Add `TYPE_COLORS` constant near theme definitions:
```typescript
const TYPE_COLORS: Record<string, string> = {
  schema: '#8b5cf6',
  model: '#06b6d4',
  service: '#f59e0b',
  route: '#10b981',
  test: '#6366f1',
};
```

**Step 4: Update isRunning check**

```typescript
const isRunning = status !== null
  && status !== 'completed'
  && status !== 'failed'
  && status !== 'rejected'
  && status !== 'plan_ready';
```

**Step 5: Run client typecheck**

Run: `cd client && npx tsc --noEmit`
Expected: PASS

**Step 6: Commit**

```bash
git add client/src/components/BuilderPromptBar.tsx
git commit -m "feat(builder): add plan review UI with editable manifest"
```

---

### Task 13: Glowy animated loading bar

**Files:**
- Modify: `client/src/components/BuilderPromptBar.tsx`

**Step 1: Add keyframes style tag**

At the top of the `BuilderPromptBar` component (inside the function, before the return), add:

```typescript
const glowKeyframes = `
@keyframes builderShimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
@keyframes builderGlow {
  0%, 100% { box-shadow: 0 0 4px rgba(37, 99, 235, 0.3); }
  50% { box-shadow: 0 0 12px rgba(37, 99, 235, 0.6), 0 0 24px rgba(37, 99, 235, 0.2); }
}
@keyframes builderPulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}
@keyframes builderIndeterminate {
  0% { left: -40%; }
  100% { left: 100%; }
}
`;
```

**Step 2: Replace static progress bar with animated version**

Replace the progress bar section (the `isRunning && (...)` block) with:

```tsx
{isRunning && (
  <>
    <style>{glowKeyframes}</style>
    <div style={{
      height: '4px', borderRadius: '2px', backgroundColor: theme.progressBg,
      overflow: 'hidden', position: 'relative',
      animation: 'builderGlow 2s ease-in-out infinite',
    }}>
      {status === 'planning' ? (
        /* Indeterminate shimmer during planning */
        <div style={{
          position: 'absolute', height: '100%', width: '40%',
          background: `linear-gradient(90deg, transparent, ${theme.progressFill}, transparent)`,
          animation: 'builderIndeterminate 1.5s ease-in-out infinite',
        }} />
      ) : (
        /* Determinate fill with shimmer during generation */
        <div style={{
          height: '100%', width: `${getProgressPercent(status)}%`,
          borderRadius: '2px', transition: 'width 0.6s ease',
          background: `linear-gradient(90deg, ${theme.progressFill}, #60a5fa, ${theme.progressFill})`,
          backgroundSize: '200% 100%',
          animation: 'builderShimmer 2s linear infinite, builderPulse 1.5s ease-in-out infinite',
        }} />
      )}
    </div>
  </>
)}
```

**Step 3: Add green glow for completed status**

After the progress bar, add a completed glow effect:
```tsx
{status === 'completed' && (
  <div style={{
    height: '4px', borderRadius: '2px', width: '100%',
    backgroundColor: theme.successText,
    boxShadow: `0 0 8px ${theme.successText}40, 0 0 16px ${theme.successText}20`,
  }} />
)}
```

**Step 4: Run client typecheck**

Run: `cd client && npx tsc --noEmit`
Expected: PASS

**Step 5: Commit**

```bash
git add client/src/components/BuilderPromptBar.tsx
git commit -m "feat(builder): glowy animated loading bar with shimmer and pulse"
```

---

## Batch 5: Context Reduction + Verification

### Task 14: Reduce context bundle size for faster generation

**Files:**
- Modify: `src/services/builder/context-reader.ts`

**Step 1: Add trimContextForGeneration function**

Add after `formatContextForPrompt` in `context-reader.ts`:

```typescript
const CONVENTIONS_SECTIONS = [
  '## Tech Stack',
  '## Key Commands',
  '## Code Style & Conventions',
  '## Common Gotchas',
];

export function trimConventions(fullConventions: string, sections: string[] = CONVENTIONS_SECTIONS): string {
  if (!fullConventions) return '';
  const lines = fullConventions.split('\n');
  const result: string[] = [];
  let capturing = false;

  for (const line of lines) {
    if (sections.some((s) => line.startsWith(s))) {
      capturing = true;
    } else if (line.startsWith('## ') && capturing) {
      capturing = false;
    }
    if (capturing) result.push(line);
  }

  return result.join('\n');
}

export function formatContextForGeneration(bundle: ContextBundle): string {
  const parts: string[] = [];

  // Trimmed conventions instead of full CLAUDE.md
  const trimmed = trimConventions(bundle.projectConventions);
  if (trimmed) {
    parts.push('## Project Conventions (excerpt)\n```\n' + trimmed + '\n```\n');
  }

  // Only one example (schema) — the plan constrains the rest
  if (bundle.exampleSchema) {
    parts.push(
      '## Example Schema (user.schema.ts)\n```typescript\n' + bundle.exampleSchema + '\n```\n'
    );
  }

  return parts.join('\n');
}
```

**Step 2: Use formatContextForGeneration in code-generator**

In `src/services/builder/code-generator.ts`, update `generateCode` to use the slimmer formatter when a plan is provided:

```typescript
import { formatContextForPrompt, formatContextForGeneration, type ContextBundle } from './context-reader.js';

// Inside generateCode:
const contextText = plan ? formatContextForGeneration(context) : formatContextForPrompt(context);
```

**Step 3: Run typecheck**

Run: `npx tsc --noEmit`
Expected: PASS

**Step 4: Commit**

```bash
git add src/services/builder/context-reader.ts src/services/builder/code-generator.ts
git commit -m "feat(builder): reduce context bundle for plan-constrained generation"
```

---

### Task 15: Full verification pass

**Step 1: Run server validate**

Run: `npm run validate`
Expected: lint + typecheck + test all PASS

**Step 2: Run client checks**

Run: `cd client && npx tsc --noEmit && npx vitest run`
Expected: typecheck PASS, all tests PASS

**Step 3: Final commit if any fixes needed**

Fix any issues discovered during validation, commit with descriptive message.

---

## Summary

| Batch | Tasks | Focus |
|-------|-------|-------|
| 1 | 1-3 | Schema + model + delta plumbing |
| 2 | 4-8 | Server: plan generation, pipeline split, routes, timeout |
| 3 | 9-11 | Client: types, store, API |
| 4 | 12-13 | Client UI: plan review, glowy bar |
| 5 | 14-15 | Context reduction, full verification |
